using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;

namespace FmgLib.MauiMarkup.Generator.Extensions;

/// <summary>
/// Builds the generated extension methods for a given MAUI control or attached property.
/// </summary>
public sealed partial class ExtensionGenerator
{
    readonly Compilation compilation;
    readonly CancellationToken cancellationToken;
    readonly INamedTypeSymbol mainSymbol;
    readonly bool isVisualElement;
    bool isGeneratedExtension = false;
    readonly AttachedModel? attachedModel;
    List<string> bindablePropertyNames = new();
    List<string> redefinedProperties = new();

    StringBuilder builder = new();

    public ExtensionGenerator(Compilation compilation, INamedTypeSymbol symbol, CancellationToken cancellationToken)
    {
        this.compilation = compilation;
        this.mainSymbol = symbol;
        this.cancellationToken = cancellationToken;
        isVisualElement = Helpers.IsVisualElement(mainSymbol);
    }

    public ExtensionGenerator(Compilation compilation, AttachedModel attachedModel, CancellationToken cancellationToken)
    {
        this.compilation = compilation;
        this.mainSymbol = attachedModel.MainSymbol;
        this.cancellationToken = cancellationToken;
        isVisualElement = Helpers.IsVisualElement(mainSymbol);
        this.attachedModel = attachedModel;
    }

    public (string, string, bool) Build()
    {
        builder.Clear();
        builder.AppendLine("//");
        builder.AppendLine("// <auto-generated-fmglib-mauimarkup-generator />");
        builder.AppendLine("//");
        builder.AppendLine();

        GenerateExtensionNameSpace();

        builder.AppendLine();

        return ($"{mainSymbol.ContainingNamespace.ToDisplayString()}.{Helpers.GetNormalizedFileName(mainSymbol)}{(attachedModel != null ? "Attached" : "")}", builder.ToString(), isGeneratedExtension);
    }

    void GenerateExtensionNameSpace()
    {
        var className = $"{Helpers.GetNormalizedClassName(mainSymbol)}{(attachedModel != null ? "Attached" : "")}Extension";

        builder.Append($@"
namespace FmgLib.MauiMarkup;

public static partial class {className}
{{");

        GenerateClassExtensionBody();

        builder.AppendLine($@"
}}
");
    }

    void GenerateClassExtensionBody()
    {
        cancellationToken.ThrowIfCancellationRequested();

        var editorBrowsableAttribute = compilation.FindNamedType("System.ComponentModel.EditorBrowsableAttribute");
        var bindablePropertyType = compilation.FindNamedType("Microsoft.Maui.Controls.BindableProperty");
        var members = mainSymbol
            .GetMembers()
            .Where(member => SymbolEqualityComparer.Default.Equals(member.ContainingType, mainSymbol))
            .ToArray();

        var propertiesMap = members
            .OfType<IPropertySymbol>()
            .Where(IsEligibleProperty)
            .OrderBy(property => property.Name, StringComparer.Ordinal)
            .ToList();

        redefinedProperties = IdentifyRedefinedProperties(propertiesMap);

        var fieldsMap = members
            .OfType<IFieldSymbol>()
            .Where(IsEligibleField)
            .ToList();

        bindablePropertyNames = fieldsMap
            .Where(field => field.IsStatic &&
                ((bindablePropertyType != null && SymbolEqualityComparer.Default.Equals(field.Type, bindablePropertyType)) ||
                 field.Type.GetFullyQualifiedName().Equals("Microsoft.Maui.Controls.BindableProperty", StringComparison.Ordinal)))
            .Select(field => field.Name.Replace("PropertyKey", string.Empty).Replace("Property", string.Empty))
            .ToList();

        var properties = propertiesMap
            .Where(property => (!property.IsReadOnly && !IsSetterRestricted(property)) || bindablePropertyNames.Any(name => name.Equals(property.Name, StringComparison.Ordinal)))
            .ToList();

        var readOnlyListProperties = propertiesMap
            .Where(property => property.IsReadOnly &&
                !bindablePropertyNames.Any(name => name.Equals(property.Name, StringComparison.InvariantCultureIgnoreCase)) &&
                IsSupportedCollection(property))
            .ToList();

        var events = members
           .OfType<IEventSymbol>()
           .Where(@event => @event.DeclaredAccessibility == Accessibility.Public)
           .Where(@event => @event.Name.IndexOf('.') < 0)
           .Where(@event => !HasEditorBrowsable(@event, editorBrowsableAttribute))
           .Where(@event => !HasObsoleteAttribute(@event))
           .GroupBy(@event => @event.Name, StringComparer.OrdinalIgnoreCase)
           .Select(group => group.First())
           .OrderBy(@event => @event.Name, StringComparer.Ordinal)
           .ToArray();

        if (attachedModel == null)
        {
            foreach (var prop in readOnlyListProperties)
            {
                cancellationToken.ThrowIfCancellationRequested();
                GenerateExtensionMethod(prop, true);
            }

            foreach (var prop in properties)
            {
                cancellationToken.ThrowIfCancellationRequested();
                GenerateExtensionMethod(prop);
            }

            foreach (var @event in events)
            {
                cancellationToken.ThrowIfCancellationRequested();
                GenerateEventMethod(@event);
            }

            if (Helpers.IsBaseImplementationOfInterface(mainSymbol, "ITextAlignment"))
                GenerateExtensionMethods_ITextAlignment(mainSymbol);
        }
        else
        {
            GenerateAttachedExtensionMethod(attachedModel!);
        }
    }

    bool IsEligibleProperty(IPropertySymbol property)
    {
        return property.DeclaredAccessibility == Accessibility.Public && !HasObsoleteAttribute(property);
    }

    bool IsEligibleField(IFieldSymbol field)
    {
        return field.DeclaredAccessibility == Accessibility.Public && !HasObsoleteAttribute(field);
    }

    static bool IsSetterRestricted(IPropertySymbol property)
    {
        return property.SetMethod == null || property.SetMethod.DeclaredAccessibility is Accessibility.Protected or Accessibility.Private or Accessibility.Internal;
    }

    bool IsSupportedCollection(IPropertySymbol property)
    {
        var type = property.Type;
        var typeName = type.Name;

        if (typeName.Equals(nameof(String), StringComparison.OrdinalIgnoreCase))
            return false;

        var implementsEnumerable = type.AllInterfaces.Any(@interface => @interface.Name.IndexOf(nameof(IEnumerable), StringComparison.Ordinal) >= 0) ||
            typeName.IndexOf(nameof(IEnumerable), StringComparison.Ordinal) >= 0;
        if (!implementsEnumerable)
            return false;

        var implementsCollection = typeName.IndexOf(nameof(ICollection), StringComparison.Ordinal) >= 0 ||
            type.AllInterfaces.Any(@interface => @interface.Name.IndexOf(nameof(ICollection), StringComparison.Ordinal) >= 0);

        var implementsList = typeName.IndexOf(nameof(IList), StringComparison.Ordinal) >= 0 ||
            type.AllInterfaces.Any(@interface => @interface.Name.IndexOf(nameof(IList), StringComparison.Ordinal) >= 0);

        if (!implementsCollection && !implementsList)
            return false;

        var isReadOnlyList = typeName.IndexOf("IReadOnlyList", StringComparison.Ordinal) >= 0 ||
            type.AllInterfaces.Any(@interface => @interface.Name.IndexOf("IReadOnlyList", StringComparison.Ordinal) >= 0);

        var blockedPrefixes = new[] { "ReadOnlyObservableCollection", "ReadOnlyCollection", "ReadOnlyDictionary" };
        var isBlockedReadOnly = blockedPrefixes.Any(prefix => typeName.StartsWith(prefix, StringComparison.Ordinal)) ||
            (type.BaseType != null && blockedPrefixes.Any(prefix => type.BaseType.Name.StartsWith(prefix, StringComparison.Ordinal)));

        return (implementsCollection || !isReadOnlyList) && !isBlockedReadOnly;
    }

    List<string> IdentifyRedefinedProperties(IEnumerable<IPropertySymbol> properties)
    {
        var basePropertyNames = new HashSet<string>(StringComparer.Ordinal);
        for (var baseType = mainSymbol.BaseType; baseType != null; baseType = baseType.BaseType)
        {
            foreach (var baseProperty in baseType.GetMembers().OfType<IPropertySymbol>())
            {
                if (baseProperty.DeclaredAccessibility == Accessibility.Public && !HasObsoleteAttribute(baseProperty))
                {
                    basePropertyNames.Add(baseProperty.Name);
                }
            }
        }

        return properties
            .Where(property => basePropertyNames.Contains(property.Name) && !property.IsOverride)
            .Select(property => property.Name)
            .ToList();
    }

    bool HasObsoleteAttribute(ISymbol symbol)
    {
        return symbol.GetAttributes().Any(attribute => attribute.AttributeClass?.Name is "ObsoleteAttribute" or "Obsolete");
    }

    bool HasEditorBrowsable(ISymbol symbol, INamedTypeSymbol? editorBrowsableAttribute)
    {
        return editorBrowsableAttribute != null && symbol.GetAttributes().Any(attribute => SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, editorBrowsableAttribute));
    }

    void GenerateExtensionMethod(IPropertySymbol propertySymbol, bool isOnlyList = false)
    {
        var propertyName = propertySymbol.Name.Split(new[] { "." }, StringSplitOptions.None).Last();
        propertyName = propertyName.Equals("class", StringComparison.Ordinal) ? "@class" : propertyName;
        var info = new PropInfo
        {
            MainSymbolName = mainSymbol.ToDisplayString(),
            BindablePropertyName = $"{mainSymbol.ToDisplayString()}.{propertySymbol.Name}Property",
            PropertySymbol = propertySymbol,
            IsBindableProperty = bindablePropertyNames.Any(_ => _.Equals(propertySymbol.Name))
        };
        info.Build(redefinedProperties);

        if (!Helpers.NotGenerateList.Contains(info.propertyName))
        {
            if (isOnlyList)
            {
                string typeName = "";
                if (propertySymbol.IsReadOnly && propertySymbol.Type is INamedTypeSymbol namedType && namedType.TypeArguments.Length == 1)
                    typeName = namedType.TypeArguments[0].ToDisplayString();

                else if (propertySymbol.IsReadOnly && propertySymbol.Type is INamedTypeSymbol namedListType &&
                            namedListType.AllInterfaces.Any(e => e.Name == nameof(IEnumerable)) &&
                            namedListType.BaseType?.TypeArguments.Length == 1)
                    typeName = namedListType.BaseType!.TypeArguments[0].ToDisplayString();

                if (!string.IsNullOrEmpty(typeName))
                    GenerateExtensionMethod_ContentProp_List(info, typeName);
            }
            else
            {
                GenerateExtensionMethod_Value(info);

                if (info.IsBindableProperty)
                {
                    GenerateExtensionMethod_BindablePropertyBuilder(info);
                    GenerateExtensionMethod_Setters(info);
                    GenerateExtensionMethod_SettersBuilder(info);
                }

                if (info.propertyTypeName.Equals("Microsoft.Maui.Controls.DataTemplate"))
                    GenerateExtensionMethod_DataTemplate(info);

                if (isVisualElement)
                {
                    if (info.propertyTypeName.Equals("double"))
                        GenerateExtensionMethod_AnimateTo(info, "DoubleTransform");

                    if (info.propertyTypeName.Equals("Microsoft.Maui.Graphics.Color"))
                        GenerateExtensionMethod_AnimateTo(info, "ColorTransform");
                }
            }

            isGeneratedExtension = true;
        }
    }

    void GenerateAttachedExtensionMethod(AttachedModel parameter)
    {
        var info = new AttachedFieldInfo
        {
            MainSymbol = mainSymbol,
            BindablePropertyName = $"{mainSymbol.ToDisplayString()}.{parameter.PropertyName}",
            ReturnTypeName = parameter.ReturnTypeName,
            DeclaringTypeName = parameter.DeclaringTypeName,
            PropertyName = parameter.PropertyName
        };
        info.Build();

        if (!Helpers.NotGenerateList.Contains(info.propertyName))
        {
            GenerateExtensionMethod_Value(info);
            GenerateExtensionMethod_BindablePropertyBuilder(info);
            GenerateExtensionMethod_Setters(info);
            GenerateExtensionMethod_SettersBuilder(info);

            isGeneratedExtension = true;
        }
    }
}
